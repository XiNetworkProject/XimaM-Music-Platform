// lib/aiGenerationService.ts
import { supabase, supabaseAdmin } from './supabase';
import { Track } from '@/lib/suno-normalize';

export interface AIGeneration {
  id: string;
  user_id: string;
  task_id: string;
  prompt: string;
  model: string;
  status: 'pending' | 'completed' | 'failed';
  created_at: string;
  completed_at?: string;
  is_favorite: boolean;
  is_public: boolean;
  play_count: number;
  like_count: number;
  share_count: number;
  metadata: {
    title?: string;
    style?: string;
    total_duration?: number;
    [key: string]: any;
  };
  tracks?: AITrack[];
}

export interface AITrack {
  id: string;
  generation_id: string;
  suno_id?: string;
  title: string;
  audio_url: string;
  stream_audio_url?: string;
  image_url?: string;
  duration: number; // En secondes, entier
  prompt?: string;
  model_name?: string;
  tags?: string[];
  // Champs √©tendus (si pr√©sents en base)
  style?: string | null;
  lyrics?: string | null;
  source_links?: string | null;
  created_at: string;
  is_favorite: boolean;
  play_count: number;
  like_count: number;
}

export interface UserQuota {
  id: string;
  user_id: string;
  plan_type: 'free' | 'basic' | 'pro' | 'enterprise';
  monthly_limit: number;
  used_this_month: number;
  reset_date: string;
  remaining: number;
}

export interface AIPlaylist {
  id: string;
  user_id: string;
  name: string;
  description?: string;
  is_public: boolean;
  created_at: string;
  updated_at: string;
  tracks?: AITrack[];
}

export interface AIUsageStats {
  total_generations: number;
  total_tracks: number;
  total_duration: number;
  favorite_count: number;
  recent_activity: Array<{
    date: string;
    generations: number;
    duration: number;
  }>;
}

class AIGenerationService {
  // üéµ Cr√©er une nouvelle g√©n√©ration
  async createGeneration(userId: string, taskId: string, title: string, style: string, prompt: string, model: string, metadata: any = {}): Promise<AIGeneration> {
    console.log("üîß Cr√©ation g√©n√©ration avec userId:", userId);
    
    const { data, error } = await supabaseAdmin
      .from('ai_generations')
      .insert({
        user_id: userId,
        task_id: taskId,
        prompt,
        model,
        status: 'pending', // Statut initial
        metadata: {
          ...metadata,
          total_duration: metadata.duration || 120,
          title: title,
          style: style
        }
      })
      .select()
      .single();

    if (error) {
      console.error("‚ùå Erreur cr√©ation g√©n√©ration:", error);
      throw new Error(`Erreur cr√©ation g√©n√©ration: ${error.message}`);
    }
    
    console.log("‚úÖ G√©n√©ration cr√©√©e avec succ√®s:", data.id);
    return data;
  }

  // üéµ Mettre √† jour le statut d'une g√©n√©ration (par task_id)
  async updateGenerationStatus(taskId: string, status: string, tracks?: Track[]): Promise<void> {
    console.log("üîÑ Mise √† jour statut g√©n√©ration par task_id:", taskId, "->", status);
    
    // Trouver la g√©n√©ration par task_id
    const { data: generation, error: findError } = await supabaseAdmin
      .from('ai_generations')
      .select('id')
      .eq('task_id', taskId)
      .single();

    if (findError || !generation) {
      console.error("‚ùå G√©n√©ration non trouv√©e pour task_id:", taskId, findError);
      throw new Error(`G√©n√©ration non trouv√©e pour task_id: ${taskId}`);
    }

    const generationId = generation.id;
    const updateData: any = { status };

    const { error } = await supabaseAdmin
      .from('ai_generations')
      .update(updateData)
      .eq('id', generationId);

    if (error) {
      console.error("‚ùå Erreur mise √† jour statut:", error);
      throw new Error(`Erreur mise √† jour statut: ${error.message}`);
    }

    console.log("‚úÖ Statut mis √† jour avec succ√®s:", generationId, "->", status);

    // Sauvegarder les tracks si fournies
    if (tracks && tracks.length > 0) {
      await this.saveTracks(generationId, tracks);
    }
  }

  // üéµ Sauvegarder les tracks d'une g√©n√©ration
  async saveTracks(generationId: string, tracks: Track[]): Promise<void> {
    // V√©rifier si des tracks existent d√©j√† pour cette g√©n√©ration
    const { data: existingTracks } = await supabaseAdmin
      .from('ai_tracks')
      .select('id, suno_id')
      .eq('generation_id', generationId);
    
    if (existingTracks && existingTracks.length > 0) {
      console.log("‚ö†Ô∏è Des tracks existent d√©j√† pour cette g√©n√©ration:", generationId);
      console.log("üìä Tracks existantes:", existingTracks);
      // Ne pas sauvegarder √† nouveau pour √©viter les doublons
      return;
    }
    
    // R√©cup√©rer le titre, le style et le mod√®le de la g√©n√©ration pour les utiliser dans les tracks
    const { data: generation, error: genError } = await supabaseAdmin
      .from('ai_generations')
      .select('metadata, prompt, model, task_id')
      .eq('id', generationId)
      .single();
    
    if (genError || !generation) {
      console.error("‚ùå Erreur r√©cup√©ration g√©n√©ration:", genError);
      throw new Error(`Impossible de r√©cup√©rer la g√©n√©ration ${generationId}`);
    }
    
    const generationTitle = generation?.metadata?.title || 'Musique g√©n√©r√©e';
    const generationStyle = generation?.metadata?.style || '';
    const generationLyrics = generation?.prompt || '';
    
    const finalModel = generation?.model || 'V4_5';
    
    console.log("üîç MOD√àLE R√âCUP√âR√â:", {
      generationId,
      modelFromDB: generation?.model,
      finalModel,
      taskId: generation?.task_id
    });
    
    const tracksData = tracks.map((track, index) => {
      // Suno renvoie les tags comme une cha√Æne s√©par√©e par des virgules
      const tagsString = track.raw?.tags || '';
      const tagsArray = typeof tagsString === 'string' 
        ? tagsString.split(',').map(t => t.trim()).filter(Boolean) 
        : (Array.isArray(tagsString) ? tagsString : []);
      
      return {
        generation_id: generationId,
        suno_id: track.id,
        title: track.title || `${generationTitle} ${index + 1}`,
        audio_url: track.audio || '',
        stream_audio_url: track.stream || '',
        image_url: track.image || '',
        duration: Math.round(track.duration || 120), // Convertir en entier
        prompt: track.raw?.prompt || generationLyrics || '', // Paroles/lyrics
        // Utiliser UNIQUEMENT le mod√®le de la g√©n√©ration (celui r√©ellement utilis√© par l'utilisateur)
        // Le modelName de Suno (chirp-auk) est un identifiant interne, pas le nom du mod√®le
        model_name: finalModel,
        tags: tagsArray, // Tags Suno (genres/styles)
        // Style musical s√©par√©
        style: generationStyle || track.raw?.style || tagsString || null,
        lyrics: track.raw?.lyrics || track.raw?.prompt || generationLyrics || null,
        source_links: track.raw?.links ? JSON.stringify(track.raw.links) : null
      };
    });

    console.log("üìä Donn√©es tracks format√©es:", tracksData);

    const { error } = await supabaseAdmin
      .from('ai_tracks')
      .insert(tracksData);

    if (error) {
      console.error("‚ùå Erreur Supabase:", error);
      throw new Error(`Erreur sauvegarde tracks: ${error.message}`);
    }
    
    console.log("‚úÖ Tracks sauvegard√©es avec succ√®s");
  }

  // üìä Obtenir le quota d'un utilisateur
  async getUserQuota(userId: string): Promise<UserQuota> {
    const { data, error } = await supabase
      .rpc('get_user_quota_remaining', { user_uuid: userId });

    if (error) throw new Error(`Erreur quota: ${error.message}`);

    // R√©cup√©rer les d√©tails du quota
    const { data: quotaData, error: quotaError } = await supabase
      .from('user_quotas')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (quotaError && quotaError.code !== 'PGRST116') {
      throw new Error(`Erreur d√©tails quota: ${quotaError.message}`);
    }

    return {
      id: quotaData?.id || '',
      user_id: userId,
      plan_type: quotaData?.plan_type || 'free',
      monthly_limit: quotaData?.monthly_limit || 5,
      used_this_month: quotaData?.used_this_month || 0,
      reset_date: quotaData?.reset_date || new Date().toISOString(),
      remaining: data
    };
  }

  // üìä Incr√©menter l'utilisation du quota
  async incrementQuota(userId: string): Promise<boolean> {
    const { data, error } = await supabase
      .rpc('increment_ai_usage', { user_uuid: userId });

    if (error) throw new Error(`Erreur incr√©ment quota: ${error.message}`);
    return data;
  }

  // üìö Obtenir la biblioth√®que IA d'un utilisateur
  async getUserLibrary(userId: string, limit: number = 50, offset: number = 0): Promise<AIGeneration[]> {
    const { data, error } = await supabase
      .from('ai_generations')
      .select(`
        *,
        tracks:ai_tracks(*)
      `)
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) throw new Error(`Erreur biblioth√®que: ${error.message}`);
    return data || [];
  }

  // üìä Obtenir les g√©n√©rations r√©centes d'un utilisateur
  async getUserGenerations(userId: string): Promise<AIGeneration[]> {
    const { data, error } = await supabase
      .from('ai_generations')
      .select(`
        *,
        tracks:ai_tracks(*)
      `)
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(20);

    if (error) {
      console.error('Erreur r√©cup√©ration g√©n√©rations utilisateur:', error);
      return [];
    }

    return data || [];
  }

  // ‚ù§Ô∏è Marquer comme favori
  async toggleFavorite(generationId: string, userId: string): Promise<boolean> {
    const { data: current, error: fetchError } = await supabase
      .from('ai_generations')
      .select('is_favorite')
      .eq('id', generationId)
      .eq('user_id', userId)
      .single();

    if (fetchError) throw new Error(`Erreur r√©cup√©ration favori: ${fetchError.message}`);

    const newFavoriteState = !current.is_favorite;

    const { error } = await supabase
      .from('ai_generations')
      .update({ is_favorite: newFavoriteState })
      .eq('id', generationId)
      .eq('user_id', userId);

    if (error) throw new Error(`Erreur mise √† jour favori: ${error.message}`);
    return newFavoriteState;
  }

  // üìà Obtenir les statistiques d'un utilisateur
  async getUserStats(userId: string, daysBack: number = 30): Promise<AIUsageStats> {
    const { data, error } = await supabase
      .rpc('get_user_ai_stats', { 
        user_uuid: userId, 
        days_back: daysBack 
      });

    if (error) throw new Error(`Erreur statistiques: ${error.message}`);
    return data || {
      total_generations: 0,
      total_tracks: 0,
      total_duration: 0,
      favorite_count: 0,
      recent_activity: []
    };
  }

  // üìù Cr√©er une playlist IA
  async createPlaylist(userId: string, name: string, description?: string, isPublic: boolean = false): Promise<AIPlaylist> {
    const { data, error } = await supabase
      .from('ai_playlists')
      .insert({
        user_id: userId,
        name,
        description,
        is_public: isPublic
      })
      .select()
      .single();

    if (error) throw new Error(`Erreur cr√©ation playlist: ${error.message}`);
    return data;
  }

  // üéµ Ajouter une track √† une playlist
  async addTrackToPlaylist(playlistId: string, trackId: string): Promise<void> {
    const { error } = await supabase
      .from('ai_playlist_tracks')
      .insert({
        playlist_id: playlistId,
        track_id: trackId,
        position: 0 // TODO: Calculer la position
      });

    if (error) throw new Error(`Erreur ajout track: ${error.message}`);
  }

  // üìö Obtenir les playlists d'un utilisateur
  async getUserPlaylists(userId: string): Promise<AIPlaylist[]> {
    const { data, error } = await supabase
      .from('ai_playlists')
      .select(`
        *,
        tracks:ai_playlist_tracks(
          track:ai_tracks(*)
        )
      `)
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw new Error(`Erreur playlists: ${error.message}`);
    return data || [];
  }

  // üéµ Incr√©menter le compteur de lecture
  async incrementPlayCount(generationId: string): Promise<void> {
    const { error } = await supabase
      .from('ai_generations')
      .update({ 
        play_count: supabase.rpc('increment', { value: 1 })
      })
      .eq('id', generationId);

    if (error) throw new Error(`Erreur incr√©ment plays: ${error.message}`);
  }

  // üéµ Incr√©menter le compteur de likes
  async incrementLikeCount(generationId: string): Promise<void> {
    const { error } = await supabase
      .from('ai_generations')
      .update({ 
        like_count: supabase.rpc('increment', { value: 1 })
      })
      .eq('id', generationId);

    if (error) throw new Error(`Erreur incr√©ment likes: ${error.message}`);
  }

  // üéµ Incr√©menter le compteur de partages
  async incrementShareCount(generationId: string): Promise<void> {
    const { error } = await supabase
      .from('ai_generations')
      .update({ 
        share_count: supabase.rpc('increment', { value: 1 })
      })
      .eq('id', generationId);

    if (error) throw new Error(`Erreur incr√©ment shares: ${error.message}`);
  }

  // üîç Rechercher dans la biblioth√®que
  async searchLibrary(userId: string, query: string): Promise<AIGeneration[]> {
    const { data, error } = await supabase
      .from('ai_generations')
      .select(`
        *,
        tracks:ai_tracks(*)
      `)
      .eq('user_id', userId)
      .or(`prompt.ilike.%${query}%,tracks.title.ilike.%${query}%`)
      .order('created_at', { ascending: false });

    if (error) throw new Error(`Erreur recherche: ${error.message}`);
    return data || [];
  }

  // üóëÔ∏è Supprimer une g√©n√©ration
  async deleteGeneration(generationId: string, userId: string): Promise<void> {
    const { error } = await supabase
      .from('ai_generations')
      .delete()
      .eq('id', generationId)
      .eq('user_id', userId);

    if (error) throw new Error(`Erreur suppression: ${error.message}`);
  }

  // üìä Obtenir les g√©n√©rations publiques (d√©couverte)
  async getPublicGenerations(limit: number = 20, offset: number = 0): Promise<AIGeneration[]> {
    const { data, error } = await supabase
      .from('ai_generations')
      .select(`
        *,
        tracks:ai_tracks(*),
        user_id
      `)
      .eq('is_public', true)
      .eq('status', 'completed')
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) throw new Error(`Erreur g√©n√©rations publiques: ${error.message}`);
    return data || [];
  }
}

export const aiGenerationService = new AIGenerationService();
